# Inhaltsverzeichnis

1. [[#IPv4 & IPv6]]
2. [[#Kommandozeile und Konsolenbefehle]]
3.  [[#UML-Diagramme (Use Case, Aktivit√§tsdiagramm, Klassendiagramm)]] 
4. [[#Entwurf von Bildschirmausgabemasken (Softwareergonomie, Corporate Identity, Barrierefreiheit)]]
5. [[#Klassen, Attribute, Objekte, Methoden, Sichtbarkeit]]
6. [[#Skriptsprachen (z.B. Shell-Skripte)]] 
7. [[#Abbildung von Kontrollstrukturen (z.B. Verzweigungen, Schleifen) mittels Pseudocode]] 
8. [[#Fehler in einem gegebenen Quellcode finden]] 
9. [[#Schreibtischtest mit einem gegebenen Quellcode durchf√ºhren]] 
10. [[#Einfache ER-Modelle]]

---
## IPv4 & IPv6

#### IPv4
- **32-Bit-Adresse**, dezimale Schreibweise (z.B. 192.168.9.24)
- **Klasseneinteilung**:
  - **A**: 1.0.0.0 bis 126.255.255.255 (z.B. 10.x.x.x)
  - **B**: 128.0.0.0 bis 191.255.255.255 (z.B. 172.16.x.x)
  - **C**: 192.0.0.0 bis 223.255.255.255 (z.B. 192.168.x.x)
  - D: 224.0.0.0 bis 239.255.255.255 (Multicast)
  - E: 240.0.0.0 bis 255.255.255.255 (Reserviert f√ºr zuk√ºnftige oder experimentelle Zwecke)
- **Subnetting**: Erlaubt feinere Unterteilung von Netzwerken durch Anpassung der Subnetzmaske
- **Subnetzmaske berechnen**:
  - /24 = 255.255.255.0 
  - /16 = 255.255.0.0
  - /8 = 255.0.0.0
  
##### Subnetting Beispiel IPv4

- Gegeben: Netzadresse 192.168.1.0/24

- Aufgabe: In 4 gleich gro√üe Subnetze aufteilen.

- L√∂sung:

	- /24 bedeutet 256 Adressen (2^8).
	
	- F√ºr 4 Subnetze ben√∂tigen wir 2^2 = 4, daher wird die neue Maske /26.
	
	- Neue Subnetze:
	
		- 192.168.1.0/26 (erste IP: 192.168.1.1, letzte IP: 192.168.1.62, Broadcast: 192.168.1.63)
		- 192.168.1.64/26 (erste IP: 192.168.1.65, letzte IP: 192.168.1.126, Broadcast: 192.168.1.127)
		- 192.168.1.128/26 (erste IP: 192.168.1.129, letzte IP: 192.168.1.190, Broadcast: 192.168.1.191)
		- 192.168.1.192/26 (erste IP: 192.168.1.193, letzte IP: 192.168.1.254, Broadcast: 192.168.1.255)

---
#### IPv6
- **128-Bit-Adresse**, hexadezimale Schreibweise (z.B.: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)
	- f√ºhrende Nullen k√∂nnen weggelassen werden (z.B.: 2001:db8:85a3::8a2e:370:7334)
- Bietet mehr Adressen als IPv4
- **Vorteile**:
  - Keine NAT-Probleme
  - Eingebautes IPsec
  - Autokonfiguration
  - Gr√∂√üerer Adressraum
- **SLAAC** (Stateless Address Autoconfiguration) anstatt Broadcast:
  - Erm√∂glicht Ger√§ten, sich selbstst√§ndig eine IPv6-Adresse zuzuweisen
  - Verwendet Router Advertisement (RA) Nachrichten zur Adressgenerierung

##### IPv6-Typen

- **Unicast**: Kommunikation von einem Ger√§t zu einem anderen
- **Multicast**: Kommunikation von einem Ger√§t zu mehreren Ger√§ten
- **Anycast**: Kommunikation von einem Ger√§t zum n√§chstgelegenen Ger√§t in einer Gruppe

##### Subnetting in IPv6

- **IPv6-Subnetting basiert auf der Unterteilung von Pr√§fixen.**
- Standardm√§√üig haben ISPs oft ein **/48-Pr√§fix**, Organisationen nutzen h√§ufig **/64-Pr√§fixe** f√ºr einzelne Subnetze.
- **Subnetzmaske wird in Schritten von 4-Bit-Bl√∂cken erweitert**.

##### Subnetting Beispiel IPv6

- **Gegeben**: Netzadresse 2001:db8::/32

- **Aufgabe**: In 16 Subnetze unterteilen.

- **L√∂sung**:
    
    - /32 bedeutet, dass die ersten 32 Bits festgelegt sind.
    
    - F√ºr 16 Subnetze ben√∂tigen wir 4 zus√§tzliche Bits (2^4 = 16), daher wird die neue Maske /36.
    
    - Neue Subnetze:
        
        - 2001:db8:0::/36
        - 2001:db8:1::/36
        - 2001:db8:2::/36
        - ‚Ä¶ bis 2001:db8:F::/36

- **Weitere Unterteilung:**
    
    - Wenn wir ein /64-Pr√§fix aus einem /48-Netzwerk ben√∂tigen, haben wir **16 Bits zur Verf√ºgung**, um **65.536 Subnetze** zu erstellen (2^16 = 65.536).
        
    - Beispiel: Ein /48-Netzwerk **2001:db8:abcd::/48** kann in /64-Subnetze unterteilt werden:
        
        - 2001:db8:abcd:0000::/64
            
        - 2001:db8:abcd:0001::/64
            
        - ‚Ä¶
            
        - 2001:db8:abcd:ffff::/64

---

## Kommandozeile und Konsolenbefehle

### Grundlagen der Kommandozeile

- Unterschiedliche Shells/Terminals (z.B. cmd, Powershell, Bash)
- Aufbau einer Befehlszeile: Befehl, Parameter, Optionen, Argumente

#### Befehlssyntax und Parameter

- Beispiel: `dir` (Windows) oder `ls` (Linux/Mac) zur Anzeige von Dateien
- Nutzung von Parametern zur Anpassung der Ausgabe (z.B. `-l`, `/w`)

#### Praktische Anwendung

- Navigation im Dateisystem (`cd`, `pwd`)
- Erstellen und L√∂schen von Dateien/Verzeichnissen (`mkdir`, `del`, `rm`)
- Nutzung von Aliasen zur Vereinfachung von Befehlen (z.B. `alias ll='ls -la'` in Bash)

### Konsolenbefehle

##### Dateioperationen

- Windows:
	- `dir`: Anzeigen des Inhalts eines Verzeichnisses
	- `copy`: Kopieren von Dateien
	- `del`: L√∂schen von Dateien
- Linux/Mac:
	- `ls`: Anzeigen des Inhalts eines Verzeichnisses
	- `cp`: Kopieren von Dateien
	- `rm`: L√∂schen von Dateien
	- `mkdir`: Erstellen von Verzeichnissen
	- `chmod`: √Ñndern von Dateiberechtigungen

#### Netzwerktroubleshooting

- `ipconfig`(Windows) und `ifconfig`/`ip` (Linux): Anzeigen und Konfigurieren von Netzwerkschnittstellen
- `alias`: Erstellen von Befehlsaliasen (insbesondere in Unix/Linux-Umgebungen)
- `iproute2` : Erweiterte Netzwerkadministration unter Linux 
- `arp` : Anzeigen und Verwalten der ARP-Tabelle 
- `ping` : Testen der Netzwerkverbindung 
- `traceroute` / `tracert` : Verfolgen von Netzwerkrouten 
- `nslookup` : √úberpr√ºfen der Namensaufl√∂sung

---
## UML-Diagramme (Use Case, Aktivit√§tsdiagramm, Klassendiagramm)

Die **Unified Modelling Language (UML)** wird genutzt, um Softwarestrukturen und Abl√§ufe visuell darzustellen.

##### Use-Case-Diagramm (Anwendungsfalldiagramm)

- Zeigt **Funktionen und Interaktionen** zwischen Akteuren und System.
- Besteht aus...:
	- Akteuren (Personen oder externe Systeme, dargestelt als Strichm√§nnchen)
	- Use Cases (Funktionen, dargestellt als Ovale)
	- Beziehungen (Pfeile: "include" und "extend")
###### Beispiel:
Ein Benutzer kann sich in ein System einloggen und Daten speichern.

##### Aktivit√§tsdiagramm

- Zeigt **Ablauf von Prozessen** (z.B.: Login-Prozess)
- Enth√§lt...:
	- Start- und Endpunkte (Kreise)
	- Aktionen (Rechtecke mit abgerundeten Ecken)
	- Verzweigungen (Rauten, z.B. "if-else")
###### Beispiel:
Benutzer gibt Passwort ein -> System pr√ºft Passwort -> Login erfolgreich oder fehlgeschlagen

##### Klassendiagramm

- Zeigt die **Struktur von Klassen in der Software.**
- Enth√§lt...:
	- Klassen (Rechtecke mit Name, Attribute, Methoden)
	- Sichtbarkeiten (+ public, - private, # protected)
	- Beziehungen zwischen Klassen (Vererbung, Assoziation, Aggregration, Komposition)

###### Pr√ºfungsrelevante Themen:
- Welche Diagrammtypen gibt es?
- Wie erkennt man Beziehungen in Klassendiagrammen?
- Wie erstellt man ein Use-Case- oder Aktivit√§tsdiagramm?

---
## Entwurf von Bildschirmausgabemasken (Softwareergonomie, Corporate Identity, Barrierefreiheit)

###### Softwareergonomie:
- Ziel: Einfache und intuitive Benutzeroberfl√§che
- **Gestaltungsrichtlinien:**
	- **Weniger ist mehr** (kein √ºberladenes Interface)
	- **Konsistente Navigation und klare Symbole**
	- **Schnelle Reaktionszeiten** (keine langen Ladezeiten)
###### Corporate Identity (CI):
- Einheitliche Gestaltung von **Farben, Logos, Schriftarten**
- Bsp: Blau und Wei√ü f√ºr Facebook, Rot und Wei√ü f√ºr Youtube.

###### Barrierefreiheit:
- Farben f√ºr Farbenblinde anpassen (hoher Kontrast, keine alleinige Farbcodierung)
- Bedienung mit der Tastatur erm√∂glichen (Tab-Navigation)
- Screenreader-Kompatibilit√§t (alternative Texte f√ºr Bilder)

###### Pr√ºfungsrelevante Themen:
- Was macht eine gute Benutzeroberfl√§che aus?
- Wie werden Accessibility-Standards (z.B. WCAG) umgesetzt?

---
## Klassen, Attribute, Objekte, Methoden, Sichtbarkeit

###### Klasse vs Objekt:
- Eine **Klasse** ist eine Vorlage (oder Bauplan) f√ºr Dinge, die gemeinsame Eigenschaften und Verhalten haben. (z.B. ein Kunde; ein Auto). Technisch gesehen ist eine Klasse eine Definition f√ºr eine komplexe Variable (Objekt)
- Ein **Objekt/Instanz** ist ein konkretes Exemplar einer Klasse. Technisch gesehen sind Objekte Variablen einer Klasse

###### Attribute (Variablen innerhalb einer Klasse)
- Beispiel (Java, weil ich Python hasse):
```java
class Auto {
	String farbe; // Attribut
	int geschwindigkeit; // Attribut
}
```

###### Methoden (Funktionen einer Klasse):
- Beispiel (immer noch Java, weil ich Python hasse):
```java
class Auto {
	void fahren() { // hier kommen die Methode
		System.out.println("Das Auto faehrt.");
	}
}
```

###### Sichtbarkeit (public, private, protected)
- `public +`: sichtbar von jeden anderen Klasse
- `private -`: sichtbar von eigenen Klasse
- `protected #`: _(Vererbung)_ von der eigenen Klasse und abgeleiteten Klasse

###### Pr√ºfungsrelevante Themen:
- Unterschied zwischen Klasse und Objekt
- Bedeutung von `private` und `public`
- Methodenaufrufe und Konstruktoren verstehen

----
## Skriptsprachen (z.B. Shell-Skripte)

###### Bash-Skript (Linux Shell-Skript):
- Automatisierung von Aufgaben in **Linux**
- Bsp: Einfaches Bash-Skript zur Anzeige eines Textes:

```bash
#!/bin/bash
echo "Hallo Welt!"
```

- **Variablen und Schleifen:**

```bash
#!/bin/bash
name="Max"
echo "Hallo $name!"

for var in liste
do
   kommando
   ...
   kommando
done
```

###### PowerShell-Skript (Windows Shell-Skript):
- Automatisierung von Aufgaben in **Windows**\*
- \*) Seit 2016 ist pwsh auch f√ºr \*nix-Systeme verf√ºgbar.
- Bsp: Einfaches pwsh-Skript zur Anzeige eines Textes:
```powershell
Write-Host "Hallo Welt!"
```


- **Variablen und Schleifen:**
```powershell
$name = "Max"
Write-Host "Hallo $name!"

for ($i = 1; $i <= 10; $i++) {
	Write-Host "$name";
}
```

###### Pr√ºfungsrelevante Themen:
- Grundlegender Aufbau eines Skripts
- Schleifen (for, while) und Bedingungen (if)
- Dateimanipulation (ls, cp, mv, grep)

---
## Abbildung von Kontrollstrukturen (z.B. Verzweigungen, Schleifen) mittels Pseudocode

Kontrollstrukturen sind sehr wichtig bei der Erstellung des Algorithmus, und man unterscheidet bei drei prozeduralen Programmierung folgende Kontrollstrukturen:
- [[#Folgestruktur]]
- [[#Auswahl (Selektion)]]
- [[#Wiederholung (Iteration)]]

Abk√ºrzungen:
- G: gemeinsamer Bedingungsteil
- B: Bedingung
- V: Verarbeitung (= Anweisung)

### Folgestruktur

| Programmablaufplan   | Pseudocode                                                                                               |
| -------------------- | -------------------------------------------------------------------------------------------------------- |
| ![[Auswahl_001.png]] | `BEGIN`<br>    `Eingabe x`<br>    `Eingabe y`<br>    `Summe = x + y`<br>    `Ausgabe Summe`<br>`END`<br> |
Eine Folgestruktur ist die sequenzielle (Schritt f√ºr Schritt) Ausf√ºhrung von Anweisungen in der Reihenfolge, in der sie geschrieben wurde. 


### Auswahlstruktur

Man unterscheidet dabei die:
- Einseitige Auswahl: If-Struktur (nur eine Bedingung und deren Ausf√ºhrung)
- Zweiseitige Auswahl: If-Else-Struktur (zwei m√∂gliche Ausf√ºhrungspfade)
- Mehrstufige Auswahl: If-Elif-Else Struktur (mehrere Bedingungen und Pfade)
- Fallunterscheidung: Switch/Case oder Match-Statement

###### Einseitige Auswahl:

| Programmablaufplan                   | Pseudocode                                                                                                                   |
| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315134158.png]] | `BEGIN`<br>    `Eingabe zahl`<br>    `IF zahl > 0 THEN`<br>        `Ausgabe "Die Zahl ist positiv."`<br>    `ENDIF`<br>`END` |

###### Zweiseitige Auswahl

| Programmablaufplan                   | Pseudocode                                                                                                                                                                                             |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ![[Pasted image 20250315134556.png]] | `BEGIN`<br>    `Eingabe zahl`<br>    `IF zahl >= 0 THEN`<br>        `Ausgabe "Die Zahl ist positiv oder null."`<br>    `ELSE`<br>        `Ausgabe "Die Zahl ist negativ."`<br>    `ENDIF`<br>`END`<br> |

###### Mehrstufige Auswahl

| Programmablaufplan                   | Pseudocode                                                                                                                                                                                                                                                          |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315134728.png]] | `BEGIN`<br>    `Eingabe zahl`<br>    `IF zahl > 0 THEN`<br>        `Ausgabe "Die Zahl ist positiv."`<br>    `ELSEIF zahl < 0 THEN`<br>        `Ausgabe "Die Zahl ist negativ."`<br>    `ELSE`<br>        `Ausgabe "Die Zahl ist null."`<br>    `ENDIF`<br>`END`<br> |

###### Fallunterscheidung

| Programmablaufplan                   | Pseudocode                                                                                                                                                                                                                                                                                                          |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250322121859.png]] | `BEGIN`<br>    `Eingabe wochentag`<br>    `CASE wochentag OF`<br>        `"Montag":  Ausgabe "Wochenanfang!"`<br>        `"Freitag": Ausgabe "Bald Wochenende!"`<br>        `"Samstag", "Sonntag": Ausgabe "Wochenende!"`<br>        `DEFAULT: Ausgabe "Ein gew√∂hnlicher Wochentag."`<br>    `ENDCASE`<br>`END`<br> |

### Wiederholungsstruktur

Drei Arten von Wiederholungen:
- Geschlossene Schleife: 
	- Feste Anzahl von Durchl√§ufen (z√§hlergesteuert)
	- Beispiel: For-Schleife, foreach-Schleife
- Offene Schleife: 
	- Kopfgesteuerte Schleifen: Bedingung wird am Anfang gepr√ºft (while)
	- Fu√ügesteuerte Schleifen: Bedingung wird am Ende gepr√ºft (do-while)

###### Geschlossene Schleife

| Programmablaufplan                   | Pseudocode                                                                                                    |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315135325.png]] | `BEGIN`<br>    `FOR i = 1 TO 5 DO`<br>        `Ausgabe "Durchlauf Nummer: " + i`<br>    `ENDFOR`<br>`END`<br> |

###### Kopfgesteuerte Schleife

| Programmablaufplan                   | Pseudocode                                                                                                                                               |
| ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315135213.png]] | `BEGIN`<br>    `Eingabe x`<br>    `WHILE x > 0 DO`<br>        `Ausgabe "x ist noch positiv: " + x`<br>        `x = x - 1`<br>    `ENDWHILE`<br>`END`<br> |

###### Fu√ügesteuerte Schleife

| Programmablaufplan                   | Pseudocode                                                                                                      |
| ------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315135249.png]] | `BEGIN`<br>    `DO`<br>        `Eingabe x`<br>        `Ausgabe "x ist: " + x`<br>    `WHILE x > 0`<br>`END`<br> |

---
## Fehler in einem gegebenen Quellcode finden
https://www.youtube.com/watch?v=k4Ccdw-wJ9w
### Highlights

- üõ†Ô∏è **Normalit√§t von Fehlern:** Fehler geh√∂ren zum Alltag eines Entwicklers; es ist wichtig, sie als Teil des Prozesses zu akzeptieren.
- üìù **Wichtigkeit der Tests:** Tests sind essenziell f√ºr die Qualit√§tssicherung und helfen, Fehler fr√ºhzeitig zu erkennen und zu beheben.
- üîç **Fehlersuche-Systematik:** Zun√§chst einen Test schreiben, bevor man mit der Fehlersuche beginnt, um reproduzierbare Bedingungen zu schaffen.
- üîÑ **Darstellungswerkzeuge:** Konsolen-Logs sind oft effektiver als komplexe Debugger, um Fehler schnell zu identifizieren.
- üîç **Ursachenforschung:** Tiefer in die Problematik einsteigen, um die wahren Ursachen der Fehler zu finden, nicht nur die Symptome behandeln.
- ü§ù **Teamarbeit und Kommunikation:** Ein positives Teamklima f√∂rdert die L√∂sung von Fehlern und die Entwicklung eines gemeinsamen Verst√§ndnisses.
- üîÑ **Kontinuierliche Verbesserung:** Reflexion √ºber den Code und Kommunikation im Team helfen, jenseits der aktuellen Probleme zu wachsen.

### Key Insights

- üìâ **Fehler sind unvermeidlich:** Jeder Entwickler muss mit Fehlern rechnen - sie sollten nicht als Misserfolge betrachtet werden, sondern als Lerngelegenheiten. Es ist wichtig, diese Fehler zu analysieren und zu dokumentieren, um das gesamte Entwicklungsteam zu st√§rken.
    
- ‚öôÔ∏è **Die Rolle von Tests:** Tests sollten nicht als blo√üe Aufgaben betrachtet werden, sondern als integrale Teile des Entwicklungsprozesses, die zur F√∂rderung einer solid strukturierten Codebasis beitragen. Jeder Test, der geschrieben wird, verbessert nicht nur die Abdeckung, sondern lehrt auch den Entwickler, wie man allf√§llige zuk√ºnftige Probleme vorwegnimmt.
    
- ‚úÖ **Testen vor Debugging:** Bevor man sich an die Fehlersuche begibt, sollte ein Test geschrieben werden, um den Fehler immer wieder reproduzieren zu k√∂nnen. Dies gew√§hrleistet, dass alle sp√§teren √Ñnderungen gezielt auf den spezifischen Fehler abzielen.
    
- üíª **Nutzung von Tools:** Auch wenn Debugger n√ºtzlich sind, k√∂nnen einfache Logging-Methoden oft effektiver und schneller sein, um die Logik im Code zu verfolgen, besonders bei gut getesteten Anwendungen, wo die Fehler oft bereits bekannt sind.
    
- üîÑ **Tiefe Ursachenanalyse:** Der erste gefundene Grund f√ºr einen Fehler ist oft nicht die wahre Ursache. Entwickler sollten sich nicht scheuen, tiefer zu graben und weitere Fragen zu stellen, um die Situation zu kl√§ren und die grundlegenden Probleme zu identifizieren.
    
- üë©‚Äçüíª **Kollaboration in Teams:** Fehler sollten nicht in einem Vakuum behandelt werden. Das Teilen von Herausforderungen mit Teamkollegen f√ºhrt oft zu neuen Einsichten und ist ein Zeichen f√ºr eine positive Fehlerkultur, die das Lernen und Wachsen innerhalb des Teams f√∂rdert.
    
- üõ†Ô∏è **Reflexion im Code:** Alte und unzufriedenstellende Codeabschnitte sind oft die Wurzel von komplexen Fehlern. Die √úberarbeitung dieser Teile kann nicht nur die aktuelle Anwendungsleistung verbessern, sondern hilft auch, die zugrunde liegenden Probleme zu adressieren und die allgemeine Codequalit√§t zu erh√∂hen.
    

Insgesamt wird eine klare Struktur und ein methodischer Ansatz bei der Fehlersuche und Fehlervermeidung gelegt. Mit der richtigen Einstellung zu Tests, dem Erkennen der Normalit√§t von Fehlern und der F√∂rderung einer positiven Teamdynamik k√∂nnen Entwickler ihre F√§higkeiten verbessern und effektiver arbeiten, w√§hrend sie gleichzeitig ein produktives und lernf√∂rderndes Umfeld schaffen.

----
## Schreibtischtest mit einem gegebenen Quellcode durchf√ºhren

https://www.youtube.com/watch?v=MY_afAp5tZE

Wir stellen uns vor, dass der Code in unserem Gehirn ausgef√ºhrt wird. Dann zeichnen wir eine Tabelle und tragen die Soll-Ausgaben darauf ein.

----
## Einfache ER-Modelle (relationale Datenbanken nach Chen-Notation)

Eine relationale Datenbank besteht aus:

- Tabellen (Relationen)
- Zeilen (Tupel)
- Spalten (Attribute)
- Prim√§rschl√ºssel (PK)
- Fremdschl√ºssel (FK)

Sie organisiert Daten in tabellarischer Form, wobei die Tabellen durch definierte Beziehungen miteinander verkn√ºpft sind.

Vorteile: Datenkonsistenz, einfache Abfragen
Nachteile: Planungskomplexit√§t, Leistungsprobleme bei vielen Daten

#### Entit√§t (Entity) 

Eine Entit√§t ist ein eindeutig identifizierbares Objekt/Konzept aus der realen Welt, welches in einer Datenbank gespeichert werden kann. 

#### Entit√§tsmenge/Entit√§tstyp 

Die Entit√§tsmenge ist die Gesamtheit aller gleichen Entit√§ten. Gleich bedeutet in dem Fall, dass sie mit den gleichen Attributen beschrieben werden. 

#### Attribut 
Ein Attribut ist eine Eigenschaft einer Entit√§t. Das kann zum Beispiel der Name, oder die Farbe eines Objektes sein. 

#### Beziehung (Relationship) 
Eine Beziehung ist eine Verkn√ºpfung zwischen zwei oder mehreren Entit√§ten 

#### Kardinalit√§t 
Eine Kardinalit√§t beschreibt wie viele Entit√§ten eines Types in Beziehung mit Entit√§ten eines anderen Types stehen. M√∂gliche Kardinalit√§ten sind: 1:n, m:n, 1:1

==!Wichtig: m:n Kardinalit√§ten m√ºssen durch eine eigene Tabelle (Beziehungstabelle/Hilfstabelle) dargestellt werden. Zu dieser Tabelle werden dann 1:n Beziehungen hergestellt.==

#### Prim√§rschl√ºssel (Primary Key, PK) 

Ein Prim√§rschl√ºssel ist ein Attribut oder eine Kombination von Attributen einer Entit√§t, welches diese eindeutig identifiziert. Innerhalb einer Tabelle darf kein Prim√§rschl√ºsselwert mehrfach vorkommen (Eindeutigkeit) und der Prim√§rschl√ºssel darf nicht NULL sein. 

#### Fremdschl√ºssel (Foreign Key, FK) 
Ein Fremdschl√ºssel ist ein Attribut oder eine Attributkombination in einer Tabelle, das auf den Prim√§rschl√ºssel einer anderen (oder derselben) Tabelle verweist. Der Fremdschl√ºssel stellt damit eine referentielle Integrit√§t zwischen den Tabellen her. 

#### Normalisierung 

Die Normalisierung ist ein systematischer Prozess zur Strukturierung von Datenbanken, der Redundanzen vermeidet und Datenanomalien verhindert. Es gibt 3 verschiedene Normalformen (NF)

#### Referenzielle Integrit√§t 

Referentielle Integrit√§t sind Regeln bei Relationalen Datenbanken, die sicherstellen, dass Beziehungen zwischen Tabellen konsistent bleiben. Sie garantiert, dass Fremdschl√ºssel nur auf wirklich existierende Prim√§rschl√ºssel verweisen d√ºrfen. Dies wird durch zwei Hauptregeln gew√§hrleistet: 

1. Ein Fremdschl√ºssel muss auf einen existierenden Prim√§rschl√ºssel verweisen oder NULL sein 
2. Ein Prim√§rschl√ºssel kann nicht gel√∂scht oder ge√§ndert werden, solange noch Fremdschl√ºssel darauf verweisen

### Chen-Notation


![[Pasted image 20250322123652.png]]



----