
# Inhaltsverzeichnis

1. [[#Fehler erkennen, analysieren und beheben]]
2. [[#Algorithmen formulieren und Programme entwickeln]]
3. [[#Datenbanken modellieren und erstellen]]

---
## Fehler erkennen, analysieren und beheben

**Debugging**: Der Prozess des Identifizierens und Behebens von Fehlern in der Software. Dies umfasst das Setzen von Breakpoints, um den Code anzuhalten und zu überprüfen.

**Breakpoint**: Ein Punkt im Code, an dem die Ausführung angehalten wird, um den Zustand der Anwendung zu überprüfen.

**Testverfahren**:

- **Dynamische Testverfahren**: Testen durch Ausführung der Software, um Laufzeitfehler zu identifizieren. Beispiele sind Black Box und White Box Tests.

- **Statische Testverfahren**: Testen ohne Ausführung der Software, z.B. Code-Reviews und Inspektionen.

- **Black Box Testing**: Testen der Funktionalität ohne Kenntnis des internen Codes.

- **White Box Testing**: Testen mit Kenntnis des internen Codes, um spezifische Pfade und Bedingungen zu überprüfen.

- **Review**: Systematische Überprüfung von Dokumenten und Code durch Kollegen.

- **Extremwertetest**: Testen mit extremen Eingabewerten, um die Robustheit der Software zu überprüfen.

**Komponententest (Unit-Test):** Ebene des Softwaretests, bei der es um die Überprüfung der einzelnen Komponenten oder Einheiten eines Systems geht.

**Integrationstest:** Bezieht sich auf den Prozess des Testens der Schnittstellen zwischen zwei oder mehr Komponenten oder Softwaremodulen, um zu beurteilen, wie Daten zwischen ihnen übertragen werden.

**Systemtest:** Art des Softwaretests, bei denen das System als Ganzes geprüft wird.

---
## Algorithmen formulieren und Programme entwickeln

Mit Hilfe von Kontrollstrukturen, UML oder der Abbildung von Pseudocode kann man ein gewisses Verständnis von Programmabläufen erzeugen, ohne dabei den Code selbst konkret kennen zu müssen.

### Kontrollstrukturen

- [[#Folgestruktur]]
- [[#Auswahl (Selektion)]]
- [[#Wiederholung (Iteration)]]

Abkürzungen:
- G: gemeinsamer Bedingungsteil
- B: Bedingung
- V: Verarbeitung (= Anweisung)

#### Folgestruktur

| Programmablaufplan   | Pseudocode                                                                                               |
| -------------------- | -------------------------------------------------------------------------------------------------------- |
| ![[Auswahl_001.png]] | `BEGIN`<br>    `Eingabe x`<br>    `Eingabe y`<br>    `Summe = x + y`<br>    `Ausgabe Summe`<br>`END`<br> |
Eine Folgestruktur ist die sequenzielle (Schritt für Schritt) Ausführung von Anweisungen in der Reihenfolge, in der sie geschrieben wurde. 


#### Auswahlstruktur

Man unterscheidet dabei die:
- Einseitige Auswahl: If-Struktur (nur eine Bedingung und deren Ausführung)
- Zweiseitige Auswahl: If-Else-Struktur (zwei mögliche Ausführungspfade)
- Mehrstufige Auswahl: If-Elif-Else Struktur (mehrere Bedingungen und Pfade)
- Fallunterscheidung: Switch/Case oder Match-Statement

###### Einseitige Auswahl:

| Programmablaufplan                   | Pseudocode                                                                                                                   |
| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315134158.png]] | `BEGIN`<br>    `Eingabe zahl`<br>    `IF zahl > 0 THEN`<br>        `Ausgabe "Die Zahl ist positiv."`<br>    `ENDIF`<br>`END` |

###### Zweiseitige Auswahl

| Programmablaufplan                   | Pseudocode                                                                                                                                                                                             |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ![[Pasted image 20250315134556.png]] | `BEGIN`<br>    `Eingabe zahl`<br>    `IF zahl >= 0 THEN`<br>        `Ausgabe "Die Zahl ist positiv oder null."`<br>    `ELSE`<br>        `Ausgabe "Die Zahl ist negativ."`<br>    `ENDIF`<br>`END`<br> |

###### Mehrstufige Auswahl

| Programmablaufplan                   | Pseudocode                                                                                                                                                                                                                                                          |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315134728.png]] | `BEGIN`<br>    `Eingabe zahl`<br>    `IF zahl > 0 THEN`<br>        `Ausgabe "Die Zahl ist positiv."`<br>    `ELSEIF zahl < 0 THEN`<br>        `Ausgabe "Die Zahl ist negativ."`<br>    `ELSE`<br>        `Ausgabe "Die Zahl ist null."`<br>    `ENDIF`<br>`END`<br> |

###### Fallunterscheidung

| Programmablaufplan                   | Pseudocode                                                                                                                                                                                                                                                                                                          |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250322121859.png]] | `BEGIN`<br>    `Eingabe wochentag`<br>    `CASE wochentag OF`<br>        `"Montag":  Ausgabe "Wochenanfang!"`<br>        `"Freitag": Ausgabe "Bald Wochenende!"`<br>        `"Samstag", "Sonntag": Ausgabe "Wochenende!"`<br>        `DEFAULT: Ausgabe "Ein gewöhnlicher Wochentag."`<br>    `ENDCASE`<br>`END`<br> |

#### Wiederholungsstruktur

Drei Arten von Wiederholungen:
- Geschlossene Schleife: 
	- Feste Anzahl von Durchläufen (zählergesteuert)
	- Beispiel: For-Schleife, foreach-Schleife
- Offene Schleife: 
	- Kopfgesteuerte Schleifen: Bedingung wird am Anfang geprüft (while)
	- Fußgesteuerte Schleifen: Bedingung wird am Ende geprüft (do-while)

###### Geschlossene Schleife

| Programmablaufplan                   | Pseudocode                                                                                                    |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315135325.png]] | `BEGIN`<br>    `FOR i = 1 TO 5 DO`<br>        `Ausgabe "Durchlauf Nummer: " + i`<br>    `ENDFOR`<br>`END`<br> |

###### Kopfgesteuerte Schleife

| Programmablaufplan                   | Pseudocode                                                                                                                                               |
| ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315135213.png]] | `BEGIN`<br>    `Eingabe x`<br>    `WHILE x > 0 DO`<br>        `Ausgabe "x ist noch positiv: " + x`<br>        `x = x - 1`<br>    `ENDWHILE`<br>`END`<br> |

###### Fußgesteuerte Schleife

| Programmablaufplan                   | Pseudocode                                                                                                      |
| ------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20250315135249.png]] | `BEGIN`<br>    `DO`<br>        `Eingabe x`<br>        `Ausgabe "x ist: " + x`<br>    `WHILE x > 0`<br>`END`<br> |

### UML

Die **Unified Modelling Language (UML)** wird genutzt, um Softwarestrukturen und Abläufe visuell darzustellen.

Folgende UML-Diagramme gibt es und sind relevant:
- Zustandsdiagramm
- Aktivitätsdiagramm
- Use-Case-Diagramm
- Sequenzdiagramm
- Klassendiagramm

#### Zustandsdiagramm

Darstellung eines endlichen Automaten, um das Verhalten eines Systems zu visualisieren. Dabei werden sowohl Aktionen unterstützt, die vom Zustand des Systems und einem auslösenden Ereignis abhängen (wie in Mealy-Automaten), als auch Eintritts- und Austritts-Aktionen, die eher zustands- als aktionsorientiert sind (wie in Moore-Automaten).

**Bestandteile:**

- Start/Stop: Einstieg und Ausstieg in den Ablauf werden analog zum Aktivitätsdiagramm dargestellt.
- Zustände: Die einzelnen Zustände werden mit abgerundeten Rechtecken dargestellt.
- Zustandsübergänge: Auch Transitionen genannt.

![[{4F7DD14E-0EF1-47F9-B2F6-EA53BD00CE80}.png]]


- Effekte und Guards: Transitionen können einen Effekt haben, der beim Durchlaufen auftritt. Sie können mit Guards geschützt werden. Auch zeitliche Ergeignisse können modelliert werden.

![[Pasted image 20250805152842.png]]


- Verhaltensspezifikation: Zustände können Verhalten beschreiben, das ausgeführt wird, sobald der Zustand eintritt (entry), wenn er verlassen wird (exit) oder während der gesamten Lebenszeit des Zustands (do).

![[{844B5599-3E5A-462F-A9B2-5248502A846E}.png]]
![[{7F346F0B-105B-44C0-899F-585B87F953AA}.png]]

#### Aktivitätsdiagramm

Darstellung eines Flussdiagramms, das die von einem System ausgeführten Aktivitäten abbildet. Praktisch ist ein solches Diagramm um auf Geschäfts- und Entwicklungsebene eine gemeinsame Basis zu finden zum Verständnis derselben Prozesse und Verhaltensweisen. 

**Bestandteile:**

- Aktion: Ein Schritt in der Aktivität, bei dem von Benutzern oder der Software eine bestimmte Aufgabe ausgeführt wird.
- Entscheidungsknoten: Eine an eine Bedingung geknüpfte Verzweigung im Fluss, die in Form eines Diamanten dargestellt wird. Entscheidungsknoten umfassen einen einzigen Input und zwei oder mehr Outputs.
- Kontrollflüsse: Andere Bezeichnung für Konnektoren, die den Fluss zwischen Schritten im Diagramm anzeigen.
- Startknoten: Symbolisiert den Beginn der Aktivität. Der Startknoten wird mit einem schwarzen Kreis dargestellt.
- Endknoten: Stellt den finalen Schritt in der Aktivität dar. Der Endknoten wird von einem umrandeten schwarzen Kreis symbolisiert.

![[Pasted image 20251007102633.png]]

#### Use-Case-Diagramm

Stellt Angaben über sogenannte Akteure innerhalb eines Systems zusammen und deren Interaktionen mit diesem System. Sinnvoll ist es ein Use-Case-Diagramm zu nutzen, wenn man beispielsweise Szenarien darstellen will, in denen ein System mit anderen externen Systemen, Personen oder Organisationen interagiert.

**Bestandteile:**

- Akteure: Die Nutzer, die mit einem System interagieren. Dabei kann es sich um Personen, Organisationen oder auch externe Systeme handeln, welche mit dem darzustellendem System interagieren.
- System: Eine bestimmte Abfolge von Aktionen und Interaktionen zwischen Akteuren und dem System. Ein System wird auch manchmal als Szenario bezeichnet.
- Ziele: Das Endergebnis der meisten Anwendungsfälle. Ein gelungenes Diagramm sollte die Aktivitäten und Varianten darstellen, die zur Verwirklichung des Ziels führen.

![[Pasted image 20251007132218.png]]

#### Sequenzdiagramm

Abbildung der Interaktion zwischen einer Gruppe von Objekten sowie die Reihenfolge ab. Nützlich ist ein solches Diagramm um zu verstehen, welche Anforderungen ein neues System stellt oder um bereits bestehende Prozesse grafisch festzuhalten.

**Bestandteile:**

- Objekt: Darstellung einer Klasse oder eines Objekts. 
- Aktivitätsbalken: Repräsentiert die Zeit, die ein Objekt zum Abschließen einer Aufgabe benötigt. Je länger die Ausführung dauert, umso länger der Balken.
- Akteur: Entität, die mit dem System interagieren.
- Lebenslinien: Gestrichelte senkrechte Linie repräsentiert die aufeinanderfolgenden Ereignisse, die einem Objekt im Verlauf des dargestellten Prozesses zustoßen.
- Optionsschleifen: Darstellung von "Wenn-dann"-Szenarien.

![[Pasted image 20251007135712.png]]

#### Klassendiagramm

Hierbei handelt es sich um eine Art Strukturdiagramm, welches beschreibt, was das System enthalten muss. Software-Ingenieure benutzen diese häufig, um Software-Architektur zu dokumentieren.

**Bestandteile:**

- Oberer Teil: Enthält die Bezeichnung der Klasse.
- Mittelteil: Enthält die Attribute der Klasse. Hier werden die Eigenschaften der Klasse eingetragen.
- Unterer Teil: Enthält die Methoden der Klasse. Dargestellt werden die Methoden im Listenformat (eine Methode pro Zeile).

**Zugriffsmodifikatoren:**

- Öffentlich (+)
- Privat (-)
- Geschützt (#)
- Paket (~)
- Abgeleitet (/): berechnetes/abgeleitetes Attribut
- Statisch (unterstrichen): gehört zur Klasse, nicht zur Instanz

**Interaktionen:**

- Assoziation: Einfache Beziehung zwischen Klassen (durchgezogene Linie)
- Vererbung: Unterklasse übernimmt die Eigenschaften einer Oberklasse. Dargestellt mit einer Verbindungslinie mit Pfeil von einer Oberklasse ausgehend zu einer Unterklasse.
- Multiplizität/Kardinalität: Anzahl der Instanzen in einer Beziehung (z.B. 1, 0..1, _, 1.._)
- gerichtete Assoziation: Beziehung mit Navigationsrichtung (Linie mit offenem Pfeil)
- Aggregation: "hat-ein"-Beziehung, Teile existieren unabhängig (leere Raute)
- Komposition: Starke "hat-ein"-Beziehung, Teile existieren nicht ohne Ganzes (gefüllte Raute)
- Implementierung: Klasse implementiert Interface (gestrichelte Linie mit leerem Dreieck)

**Anmerkung:** Die Vererbungsdarstellung ist umgekehrt – der Pfeil zeigt von der Unterklasse zur Oberklasse.


![[Pasted image 20251007142349.png]]

---
## Datenbanken modellieren und erstellen

###### Relationale Datenbanken: 
Daten werden im tabellarischen Format mit Zeilen und Spalten gespeichert. Die Spalten enthalten Datenattribute und die Zeilen haben Datenwerte. In einer relationalen Datenbank lassen sich die Tabellen verknüpfen, um Zusammenhänge zwischen verschiedenen Datenpunkten zu erhalten. 

In einer relationalen Datenbank wird jeder Tabelle ein Primärschlüssel vergeben zur eindeutigen Identifikation. Daraus resultiert für jede Tabelle eine Kennungsspalte. Der Primärschlüssel wird verwendet, um Beziehungen zwischen Tabellen herzustellen. Verwendet wird es, um Zeilen zwischen Tabellen miteinander zu verknüpfen, als Fremdschlüssel in einer anderen Tabelle.

Mit SQL-Abfragen kann man dann mit miteinander verknüpften Tabellen interagieren, beispielsweise für eine Abfrage von Daten.

**Beispiel:**

Man nehme einen Einzelhändler, der seine Produkte und seine Kunden in einer Tabelle darstellt. Die Produkttabelle enthält Informationen über einzelne Produkte (hier z.B. Produktname und Produktkosten). Die Kundentabelle enthält Informationen über einzelne Kunden und deren Produkteinkäufe beim Einzelhändler. 

Über eine SQL-Abfrage lassen sich nun die beiden Tabellen über den Primärschlüssel aus Produkttabelle und Fremdschlüssel aus Kundentabelle verknüpfen um beispielsweise die Inhalte beider Tabellen über eine Abfrage darzustellen.


Produkttabelle:

| Produkt-ID (Primärschlüssel) | Produktname | Produktkosten |
| ---------------------------- | ----------- | ------------- |
| P1                           | Produkt_A   | 100€          |
| P2                           | Produkt_B   | 50€           |
| P3                           | Produkt_C   | 25€           |

Kundentabelle:

| Kunden-ID (Primärschlüssel) | Kundenname | Artikel_gekauft (Fremdschlüssel) |
| --------------------------- | ---------- | -------------------------------- |
| K1                          | Kunde_A    | P2                               |
| K2                          | Kunde_B    | P1                               |
| K3                          | Kunde_C    | P3                               |

---

###### Nicht-relationale Datenbanken: 
Verwenden eine Vielzahl von Datenmodellen für den Zugriff auf und die Verwaltung von Daten. Sie sind speziell für Anwendungen optimiert. die große Datenmengen, geringe Latenz und flexible Datenmodelle erfordern. 

Aufgrund der unterschiedlichen Art und Weisen, wie sie Daten ohne Schema verwalten und speichern, gibt es mehrere verschiedene nicht-relationale Datenbanksysteme. Daten ohne Schema sind Daten, die ohne die Einschränkungen gespeichert werden, die relationale Datenbanken erfordern.

Gängige Typen von nicht relationalen Datenbanken wären folgende:

**Schlüssel-Werte-Datenbanken**: Eine Schlüssel-Werte-Datenbank speichert Daten als Sammlung von Schlüssel-Werte-Paaren. In einem Paar dient der Schlüssel als eindeutige Kennung. Sowohl Schlüssel als auch Werte können alles sein, von einfachen Objekten bis hin zu komplexen zusammengesetzten Objekten.

**Beispiel:**

![[Pasted image 20251008103105.png]]**Dokumentdatenbanken:** Dokumentdatenbanken haben dasselbe Dokumentmodellformat, das Entwickler in ihrem Anwendungscode verwenden. Sie speichern Daten als JSON-Objekte, die flexibler, halbstrukturierter und hierarchischer Natur sind.

**Beispiel:**

```
{
  Name des Unternehmens: „Beliebiges Unternehmen“,
  Adresse: {Straße: „1212 Main Street“, Ort: „Anytown"},
  Telefonnummer: „1-800-555-0101",
  Branche: [„Lebensmittelverarbeitung“, „Geräte"]
  Typ: „privat“,
  Anzahl der Mitarbeiter: 987
}
```

**Graphdatenbanken:** Graphdatenbanken sind speziell zum Speichern und Navigieren von Beziehungen konzipiert. Sie verwenden Knoten zur Speicherung von Dateneinheiten und Edges zur Speicherung von Beziehungen zwischen Einheiten.

Ein Edge hat immer einen Startknoten, einen Endknoten, einen Typ und eine Richtung. Er kann beispielsweise über- und untergeordnete Beziehungen, Aktionen und Besitzverhältnisse beschreiben.

**Beispiel:**

![[Pasted image 20251008105739.png|529x486]]

---

###### Hauptmerkmale von relationalen und nicht-relationalen Datenbanken:

**Relationale Datenbanken:**

- Datenspeicherung in tabellarischer Form und folgen strengen Regeln
- Folgt dem ACID Prinzip (Atomizität, Konsistenz, Isolation und Haltbarkeit)
- Leistung hängt vom Festplattensubsystem ab; SSDs und entsprechende RAID Konfigurationen können die Leistung verbessern.
- Nutzt SQL als Standard-Abfragesprache zur Definition und Manipulation von Daten
- Eignet sich besonders gut für strukturierte Daten mit klaren Beziehungen (z. B. Fremdschlüssel, Joins)
- Strikte Schemadefinition: Änderungen am Datenmodell erfordern oft Migrationen
- Typische Einsatzszenarien: Finanzsysteme, ERP, CRM, klassische Geschäftsanwendungen

**Nicht-relationale Datenbanken (NoSQL):**

- Flexible Datenspeicherung, nicht notwendigerweise tabellarisch (z. B. Dokumente, Key-Value-Paare, Graphen, Spalten-orientiert)
- Häufig schemalos oder schemaflexibel, was schnelle Anpassungen am Datenmodell erlaubt
- Oft optimiert für horizontale Skalierbarkeit und hohe Verfügbarkeit
- Folgen eher dem BASE-Prinzip (Basically Available, Soft state, Eventual consistency) statt strenger ACID-Eigenschaften
- Gute Leistung bei großen, verteilten Datenmengen und unstrukturierten oder semi-strukturierten Daten
- Abfragesprachen variieren stark je nach Datenbanktyp (z. B. JSON-ähnliche Abfragen bei Dokumentdatenbanken wie MongoDB)
- Typische Einsatzszenarien: Big Data, Echtzeit-Analysen, Social Media, IoT, Content Management

---

###### Datentypen:

**Nummerische Datentypen:**

|Datentyp|Von|Bis|
|---|---|---|
|BIT|1|0|
|TINYINT|0|255|
|SMALLINT|-32,768|32,767|
|INT|-2,147,483,648|2,147,483,647|
|BIGINT|-9,223,372,036,854,775,808|9,223,372,036,854,775,807|
|DECIMAL|-10^38 + 1|10^38 – 1|
|NUMERIC|-10^38 + 1|10^38 – 1|
|FLOAT|-1.79E+308|1.79E+308|
|REAL|-3.40E+38|3.40E+38|

**Datum- und Zeit-Datentypen:**

|Datentyp|Beschreibung|
|---|---|
|DATE|Speichert ein Datum im Format `YYYY-MM-DD`.|
|TIME|Speichert eine Uhrzeit im Format `HH:MM:SS`.|
|DATETIME|Speichert Datum und Uhrzeit im Format `YYYY-MM-DD HH:MM:SS`.|
|TIMESTAMP|Speichert die Anzahl der Sekunden seit der Unix-Epoche (`1970-01-01 00:00:00`).|
|YEAR|Speichert ein Jahr im 2- oder 4-stelligen Format (`1970` bis `2069`).SQL Zeichen- und String-Datentypen|

**Zeichen- und String-Datentypen:**

| Datentyp     | Beschreibung                                                         |
| ------------ | -------------------------------------------------------------------- |
| CHAR         | Feste Länge, bis zu 8.000 Zeichen.                                   |
| VARCHAR      | Variable Länge, bis zu 8.000 Zeichen.                                |
| VARCHAR(max) | Variable Länge, theoretisch bis zu 2 GB. In MySQL nicht unterstützt. |
| TEXT         | Variable Länge, maximal 2 GB.                                        |

**Unicode Zeichen- und String-Datentypen:**

|Datentyp|Beschreibung|
|---|---|
|NCHAR|Feste Länge, bis zu 4.000 Zeichen.|
|NVARCHAR|Variable Länge, bis zu 4.000 Zeichen.|
|NVARCHAR (MAX)|Variable Länge, maximal 2 GB.|

**Binäre Datentypen:**

|Datentyp|Beschreibung|
|---|---|
|BINARY|Feste Länge, bis zu 8.000 Bytes.|
|VARBINARY|Variable Länge, bis zu 8.000 Bytes.|
|VARBINARY(max)|Variable Länge, maximal 2 GB binäre Daten.|
|IMAGE|Variable Länge, maximal 2 GB binäre Daten (veraltet in neueren SQL-Versionen).|

**Spezielle Datentypen:**

|Datentyp|Beschreibung|
|---|---|
|CLOB|Speichert bis zu 2 GB Textdaten (nur in einigen Datenbanken verfügbar).|
|BLOB|Speichert große binäre Daten (z. B. Bilder oder Videos).|
|XML|Speichert XML-Daten.|
|JSON|Speichert JSON-Daten (nativ in MySQL, PostgreSQL, SQL Server, Oracle verfügbar).Fazit|

**Praktisches Beispiel einer Erstellung einer Beispieltabelle:**

```
CREATE TABLE BeispielTabelle ( 
ID INT PRIMARY KEY,
Name NVARCHAR(100), 
Alter TINYINT, 
Gehalt DECIMAL(10, 2), 
Eintrittsdatum DATE, 
Bild BLOB 
);
```
---
###### Anomalien und Redundanzen erkennen:

**Anomalien** in Datenbanken treten bei einer nicht existierenden oder fehlerhaften Normalisierung auf. Dabei unterscheidet man zwischen drei Kategorien:

- **Einfüge-Anomalie**
- **Lösch-Anomalie**
- **Änderungs-Anomalie**

Bei einem fehlerhaften oder inkorrekten Datenbankdesign kann es bei der **Einfüge-Anomalie** passieren, dass Daten gar nicht in die Datenbank übernommen werden, wenn zum Beispiel der Primärschlüssel keinen Wert erhalten hat oder eine unvollständige Eingabe von Daten zu Inkonsistenzen führt.

Bei der **Änderungs-Anomalie**, auch Update-Anomalie genannt, werden gleiche Attribute eines Datensatzes in einer Transaktion nicht automatisch geändert. So entsteht eine Inkonsistenz der Daten.

Bei einer **Lösch-Anomalie** kann es passieren, dass ein Benutzer einer Datenbank aktiv Informationen löschen will und damit indirekt, aufgrund des fehlerhaften Datenbankdesigns, andere zusammenhängende Informationen parallel mit löscht.

**Redundanzen** in Datenbanken sind ein Zeichen für ein schlechtes Datenbankdesign. Redundanzen sind doppelte Informationen in einer Datenbank bzw. Datenbank-Tabelle.

Man spricht von einer redundanzfreien Datenbank, wenn alle doppelten Informationen entfernt werden können, ohne das ein Informationsverlust stattfindet.

Mittels Normalisierung lassen sich Redundanzen entfernen. Die Normalisierung entfernt dabei doppelte Informationen, ohne das ein Informationsverlust in anderen Relationen stattfindet.

---
###### Normalisierung

<mark style="background: #FFF3A3A6;">Wichtig!:</mark> Für die AP2 sind nur die 1. bis 3. Normalform relevant!

Unter **Normalisierung** eines relationalen Datenbankmodells versteht man die Aufteilung von Attributen in mehrere Relationen (Tabellen) mithilfe der Normalisierungsregeln und deren Normalformen, sodass eine Form entsteht, die keine vermeidbaren Redundanzen mehr enthält.

Ziel der Normalisierung ist es, eine redundanzarme Datenspeicherung zu erstellen. **Redundanzarm** bedeutet, dass Informationen nicht mehrfach gespeichert werden und dadurch keine Inkonsistenzen bei Änderungen entstehen können.

Weiterhin soll die Normalisierung **Anomalien** entfernen.

Im Normalisierungsprozess gibt es fünf Normalformen, für die AP2 sind allerdings nur die Normalformen 1. bis 3. relevant. In der Regel reicht die 3. Normalform völlig aus.

---

**Grundlegende Abhängigkeitskonzepte:**

Bevor die Normalformen erklärt werden, müssen drei zentrale Begriffe verstanden werden:

**Funktionale Abhängigkeit**

Ein Attribut B ist **funktional abhängig** von einem Attribut A (geschrieben: A → B), wenn zu jedem Wert von A genau ein Wert von B gehört.

**Beispiel**: Kundennummer → Name (jede Kundennummer identifiziert genau einen Kunden mit einem bestimmten Namen)

**Voll funktionale Abhängigkeit**

Ein Attribut ist **voll funktional abhängig** von einem zusammengesetzten Schlüssel, wenn es vom gesamten Schlüssel abhängt, aber nicht nur von einzelnen Teilen davon. Dieser Begriff ist nur bei zusammengesetzten Primärschlüsseln relevant.

**Beispiel**: Bei einem Schlüssel (BestellNr, ArtikelNr) ist "Menge" voll funktional abhängig, weil man beide Schlüsselteile benötigt, um die Menge zu bestimmen. "Artikelname" wäre dagegen nur teilweise abhängig, da er nur von ArtikelNr abhängt.

**Transitive Abhängigkeit**

Eine **transitive Abhängigkeit** liegt vor, wenn A → B und B → C gilt, also C indirekt über B von A abhängt.

**Beispiel**: Kundennummer → PLZ → Ort (der Ort hängt nicht direkt von der Kundennummer ab, sondern von der Postleitzahl)

---

**Nullte Normalform (0NF) :** 

Die nullte Normalform ist dann gegeben, wenn alle Informationen in einer Tabelle vorhanden sind und noch unnormalisiert vorliegen. Sie liegt in vielen Fällen während der Anforderungsanalyse einer Datenbank vor.

Anders gesagt, befindet sich eine Tabelle in der nullten Normalform, wenn alle Datenelemente der realen Welt in einer Tabelle zusammengefasst und aufgelistet sind.

**Beispiel**:

![[image.png]]

---

**Erste Normalform (1NF):**

Die erste Normalform ist dann gegeben, wenn alle Informationen in einer Tabelle **atomar** vorliegen.

**Anforderungen**:

1. Jedes Attribut enthält nur atomare (unteilbare) Werte
2. Keine Wiederholungsgruppen
3. Jede Spalte hat einen eindeutigen Namen
4. Die Reihenfolge der Zeilen ist nicht relevant

Das bedeutet, dass jede Information innerhalb einer Tabelle eine eigene Tabellenspalte bekommt und zusammenhängende Informationen, wie zum Beispiel die Postleitzahl (PLZ) und der Ort, nicht in einer Tabellenspalte vorliegen dürfen.

Informationen, die vorher unstrukturiert und unsortiert vorlagen, werden nun einheitlich und klar strukturiert.

**Transformation**: Wiederholungsgruppen werden eliminiert, zusammengesetzte Attribute werden aufgeteilt.

Folgende Tabelle liegt in der nullten Normalform vor:

![[image.png]]

Wenn wir nun das Prinzip der ersten Normalform an, würden die Tabelle folgendermaßen aussehen:

![[image 1.png]]

---

**Zweite Normalform (2NF):**

Eine Tabelle befindet sich in der zweiten Normalform, wenn:

1. Sie sich in der ersten Normalform befindet
2. Jedes Nichtschlüsselattribut von jedem Schlüsselkandidaten **voll funktional abhängig** ist

**Wichtig**: Die 2NF ist nur bei zusammengesetzten Primärschlüsseln relevant. Bei einfachen Primärschlüsseln ist eine Tabelle in 1NF automatisch auch in 2NF.

**Problem der 2NF**: Teilabhängigkeiten, bei denen Nichtschlüsselattribute nur von einem Teil des zusammengesetzten Primärschlüssels abhängen.

**Lösung**: Teilabhängige Attribute werden in separate Tabellen ausgelagert.

In der zweiten Normalform entstehen typischerweise mehrere Tabellen mit definierten Beziehungen (1:n, n:m) zwischen ihnen.

Folgende Tabelle liegt in der ersten Normalform vor:

![[image 1.png]]

Nach der Anwendung der zweiten Normalform sieht das Ergebnis folgendermaßen aus:

![[image.png]]

Da ein Name nicht eindeutig ist, wird jedem Kunden eine Kunden eine Kundennummer zugeordnet. Diese ist der Primärschlüssel der neuen Tabelle Kunde. Danach wird das gleiche mit den Artikeln durchgeführt. Des Weiteren wird eine Rechnungspositionstabelle eingebaut, da eine Rechnung von einem Kunden eine Vielzahl an Rechnungspositionen mit verschiedenen Artikeln beinhalten kann.

In der zweiten Normalform werden auch die ersten Beziehungen in Datenbanken festgelegt.

---

**Dritte Normalform (3NF):**

Die dritte Normalform ist das Ziel einer Normalisierung in einem relationalen Datenbankmodell. Sie verhindert einerseits Anomalien und Redundanzen in Datensätzen und andererseits bietet sie genügend Performance für SQL-Abfragen.

Eine Tabelle befindet sich in der dritten Normalform, wenn:

1. Sie sich in der zweiten Normalform befindet
2. Kein Nichtschlüsselattribut transitiv vom Primärschlüssel abhängig ist

**Problem der 3NF**: Transitive Abhängigkeiten, bei denen Nichtschlüsselattribute von anderen Nichtschlüsselattributen abhängen.

**Lösung**: Die transitiv abhängigen Attribute werden in eine separate Tabelle ausgelagert.

Oft reicht die dritte Normalform aus, um die optimale Balance aus Redundanzfreiheit, Performance und Flexibilität für eine Datenbank zu gewährleisten.

Folgende Tabelle liegt in der zweiten Normalform vor:

![[image 1.png]]

Nach der Anwendung der dritten Normalform sieht das Ergebnis folgendermaßen aus:

![[image.png]]

In der Tabelle Kunde sind die Attribute Vorname, Straße und Plz abhängig vom Attribut Name, nicht vom Primärschlüssel K.-Nr.. Außerdem ist das Attribut Ort abhängig vom Attribut Plz.

Die transitiv abhängigen Spalten werden in eine weitere Untertabelle ausgelagert, da sie nicht direkt vom Schlüsselkandidaten abhängen, sondern nur indirekt.

****

###### ER-Modell

Das Entity-Relationship-Modell, abgekürzt ER-Modell oder ERM, dient als Grundlage für einen Datenbankentwurf. Bevor mittels SQL angefagen wird, Tabellen und Beziehungen anzulegen, wird erst mal mittels ER-Modell geplant, wie die Datenbankstruktur aufgebaut und funktionieren soll.

Mithilfe des Entity-Relationship-Modells soll eine Typisierung von Objekten, ihrer relationalen Beziehungen untereinander und der zu überführenden Attribute, stattfinden. 

Die Grundelemente eines jeden Entity-Relationship-Modells bilden Entitäten, Beziehungen und Attribute. Diese werden grafisch folgendermaßen dargestellt.

![[image.png]]

- Eine Entität ist ein individuell identifizierbares Objekt der Wirklichkeit.
- Eine Beziehung ist eine Verknüpfung/Zusammenhang zwischen zwei oder mehreren Entitäten
- Ein Attribut ist eine Eigenschaft, die im Kontext zu einer Entität steht.

Folgendes Beispiel eines Entity-Relationship-Modells soll zeigen, wie leicht ein Modell anhand eines realen Beispiels zu erstellen ist:

![[image.png]]

Zwischen Relationen (Tabellen/Entitäten) können Beziehungen in einer Datenbank bestehen. Angenommen man hat eine Relation Mutter und eine Relation Kind. Denkbar wären nun vier Möglichkeiten von Beziehungen zwischen den Tabellen.

- Jede Mutter hat exakt ein Kind
- Jede Mutter hat ein oder kein Kind
- Jede Mutter hat mindestens ein Kind
- Jede Mutter hat eine beliebige Anzahl von Kindern

Die Kardinalität von Beziehungen definiert, wie viele Entitäten eines Entitätstyps mit genau einer Entität des anderen am Beziehungstyp beteiligten Entitätstyp (und umgekehrt) in Relation (Beziehung) stehen können oder müssen. Die Kardinalität von Beziehungen ist in relationalen Datenbanken in folgenden Formen vorhanden: 1:1 Beziehung, 1:n Beziehung und m:n Beziehung.

**1:1 Beziehung:**

In einer 1:1 Beziehung ist jeder Datensatz in Tabelle A genau einem Datensatz in Tabelle B zugeordnet und umgekehrt. Diese Art von Beziehung sollte in der Modellierung vermieden werden, weil die meisten Informationen, die auf diese Weise in Beziehung stehen, sich in einer Tabelle befinden können. Eine 1:1 Beziehung verwendet man nur, um eine Tabelle aufgrund ihrer Komplexität zu teilen oder um einen Teil der Tabelle aus Gründen der Zugriffsrechte zu isolieren.

![[image.png]]

**1:n Beziehung:**

In einer 1:n Beziehung können einem Datensatz in Tabelle A mehrere passende Datensätze in Tabelle B zugeordnet sein, aber einem Datensatz in Tabelle B ist nie mehr als ein Datensatz in Tabelle A zugeordnet.

![[image.png]]

**m:n Beziehung:**

Bei m:n Beziehungen können jedem Datensatz in Tabelle A mehrere passende Datensätze in Tabelle 2 zugeordnet sein und umgekehrt. Diese Beziehungen können nur über eine dritte Tabelle, eine Verbindungstabelle C, realisiert werden. Die Verbindungstabelle C enthält in der Regel nur die Fremdschlüssel der beiden anderen Tabellen (A/B). Der Primärschlüssel der Verbindungstabelle wird aus diesen beiden Fremdschlüsseln gebildet. Daraus folgt, dass eine m:n Beziehung in Wirklichkeit zwei 1:n Beziehungen sind.

![[image.png]]


---

**Referenzielle Integrität:**

Die referenzielle Integrität ist ein Konzept relationaler Datenbanken, das die Konsistenz von Beziehungen zwischen Tabellen sicherstellt. Sie gewährleistet, dass Fremdschlüssel nur auf tatsächlich existierende Primärschlüssel in der referenzierten Tabelle verweisen können.

Ein Datensatz mit einem Fremdschlüssel kann nur dann gespeichert werden, wenn der Wert des Fremdschlüssels als Primärschlüssel in der referenzierten Tabelle vorhanden ist. Existiert der referenzierte Wert nicht, wird der Einfügevorgang vom Datenbanksystem abgelehnt. Dies verhindert verwaiste Datensätze, also Einträge, die auf nicht-existierende Daten verweisen.

Auch beim Löschen oder Ändern von Datensätzen greift die referenzielle Integrität. Das Datenbanksystem kann dabei unterschiedlich reagieren:

- **RESTRICT/NO ACTION**: Das Löschen wird verhindert, solange noch abhängige Datensätze existieren
- **CASCADE**: Abhängige Datensätze werden automatisch mitgelöscht oder aktualisiert
- **SET NULL**: Der Fremdschlüssel in abhängigen Datensätzen wird auf NULL gesetzt

Ohne referenzielle Integrität können inkonsistente Zustände entstehen: Datensätze verweisen auf gelöschte Einträge, Beziehungen zwischen Tabellen werden ungültig, und die Datenintegrität geht verloren. In Kombination mit einer ordnungsgemäßen Normalisierung trägt die referenzielle Integrität maßgeblich zur Datenqualität und Wartbarkeit der Datenbank bei.

---

